{
    // db via sqlalchemy related
    "dbsetup": {
        "prefix": "dbsetup",
        "body": [
            "import sqlalchemy as sa",
            "import pandas as pd",
            "import os",
            "",
            "# add run method to engine",
            "def run(self: sa.engine.Engine, sql:str) -> pd.DataFrame | None:",
            "    with self.begin() as conn:",
            "        res = conn.execute(sa.text(sql))",
            "        if res.returns_rows:",
            "            return pd.DataFrame(res.all(), columns=res.keys())",
            "",
            "sa.engine.Engine.run = run",
            "",
            "connection_string = f\"$1://$2:{os.environ['password']}@$3\"",
            "eng = sa.create_engine(connection_string)",
        ],
    },
    "dbrun0": {
        "prefix": "dbrun0",
        "body": [
            "_ = eng.run(f\"drop table $1\")",
        ],
    },
    "dbrun1": {
        "prefix": "dbrun1",
        "body": [
            "_ = eng.run(f\"select * from $1 where $2 = '$3'\")",
            "_",
        ],
    },
    "dbqry": {
        "prefix": "dbqry",
        "body": [
            "qry = f\"\"\"",
            "select",
            "    *",
            "from $1",
            "where $2 = '$3'",
            "\"\"\"",
            "",
            "df = eng.run(qry)",
            "df",
        ],
    },
    "dbhead": {
        "prefix": "dbhead",
        "body": [
            "_ = eng.run(f\"select top 5 * from $1\")",
            "print(_.head().to_string())",
        ],
    },
    "dbtop": {
        "prefix": "dbtop",
        "body": [
            "_ = eng.run(f\"select top 1 * from $1\")",
            "print(_.T.to_string())",
        ],
    },
    "dbcount1": {
        "prefix": "dbcount1",
        "body": [
            "eng.run(f\"select count(*) as n from $1\").iloc[0,0]",
        ],
    },
    "dbdrop": {
        "prefix": "dbdrop",
        "body": [
            "try:",
            "    eng.run(f\"drop table $1\")",
            "except Exception as e:",
            "    pass",
        ],
    },
    "dbgrp": {
        "prefix": "dbgrp",
        "body": [
            "qry = f\"\"\"",
            "select",
            "    $1,",
            "    $2,",
            "    count(1) as n,",
            "    sum(exp) as exp",
            "from $3",
            "where infokey = 'Version'",
            "group by 1,2",
            "order by 1,2",
            "\"\"\"",
            "",
            "df = eng.run(qry)",
            "df",
        ],
    },
    "dbctbl": {
        "prefix": "dbctbl",
        "body": [
            "tbl = \"$1\"",
            "",
            "try:",
            "    eng.run(f\"drop table {tbl}\")",
            "except Exception as e:",
            "    pass",
            "",
            "_ = eng.run(",
            "f\"\"\"",
            "create table {tbl} as (",
            "    select *",
            "    from $2",
            ") with data;",
            "\"\"\"",
            ")",
            "",
            "eng.run(f\"select count(*) from {tbl}\").iloc[0, 0]",
        ],
    },
    "dbcase": {
        "prefix": "dbcase",
        "body": [
            "qry = f\"\"\"",
            "with x as (",
            "   select",
            "   CASE",
            "       WHEN a.$1 IS NOT NULL AND b.$1 IS NULL THEN 'A_ONLY'",
            "       WHEN a.$1 IS NULL AND b.$1 IS NOT NULL THEN 'B_ONLY'",
            "       WHEN a.$2 = b.$2 THEN 'MATCH'",
            "       WHEN a.$2 <> b.$2 THEN 'MISMATCH'",
            "       ELSE 'UNKNOWN'",
            "   END AS col_check",
            "   from $1 a",
            "   full outer join $2 b",
            "   on a.$3 = b.$3 and a.$4 = b.$4",
            ") ",
            "select",
            "   col_check,",
            "   count(1) as n",
            "from x",
            "group by 1",
            "\"\"\"",
            "",
            "df = eng.run(qry)",
            "df",
        ]
    },
    // duckdb related
    "ddbimportcon": {
        "prefix": "ddbimportcon",
        "body": [
            "improt duckdb",
            "con = duckdb.connect()",
        ],
    },
    "ddbexec": {
        "prefix": "ddbexec",
        "body": [
            "res = con.execute(",
            "    \"\"\"",
            "    select",
            "        $2,",
            "        count(1) as cnt",
            "    from $1",
            "    group by 1",
            "    order by 1",
            "\"\"\"",
            ").df()",
            "",
            "res",
        ],
    },
    // teradata sql via sqlalchemy related
    "tdsetup": {
        "prefix": "tdsetup",
        "body": [
            "import sqlalchemy as alc",
            "import pandas as pd",
            "import os",
            "",
            "# add run method to engine",
            "def run(self: alc.engine.Engine, sql:str) -> pd.DataFrame | None:",
            "    with self.begin() as conn:",
            "        res = conn.execute(alc.text(sql))",
            "        if res.returns_rows:",
            "            return pd.DataFrame(res.all(), columns=res.keys())",
            "",
            "alc.engine.Engine.run = run",
            "",
            "connection_string = f\"teradatasql://$1:{os.environ['password']}@$2\"",
            "eng = alc.create_engine(connection_string)",
        ],
    },
}